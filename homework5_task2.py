# 2. Написать программу сложения и умножения двух положительных целых шестнадцатеричных чисел. При этом каждое число
#    представляется как коллекция, элементы которой — цифры числа. Например, пользователь ввёл A2 и C4F. Нужно сохранить
#    их как [‘A’, ‘2’] и [‘C’, ‘4’, ‘F’] соответственно. Сумма чисел из примера: [‘C’, ‘F’, ‘1’],
#    произведение - [‘7’, ‘C’, ‘9’, ‘F’, ‘E’].


from collections import defaultdict, deque

symbols = [str(i) for i in range(10)] + ['A', 'B', 'C', 'D', 'E', 'F']  # Генерируем список символов 16-ричн. системы

codedict = defaultdict(int)  # Создаем словарь для этих символов

for el in range(len(symbols)):  # В словаре ключ - 10-ричное число, значение - 16-ричное число
    codedict[el] = symbols[el]

first = deque(input('Введите первое число: ')) # Первое число-стек

second = deque(input('Введите второе число: ')) # Второе число-стек

new_number = deque()  # Создаем стек под новое число-сумму

flag = 0  # Обнуляем флаг
ost = 0  # Зануляем остаток при сложении

while flag != 1:  # Пока флаг не установлен
    a = first.pop() # Извлекаем с конца стека значение первого числа
    b = second.pop() # Извлекаем с конца стека значение второго числа
    a_index = 0 # Обнуляем значение ключа для извлеченного из первого числа значения
    b_index = 0 # Обнуляем значение ключа для извлеченного из второго числа значения

    for key, val in codedict.items(): # Ищем по словарю

        # Как только находим в словаре значения, которые совпадают с извлеченными, в индексы записываем 10-ричное
        # значение этого шестнадцатеричного кода

        if val == a:
            a_index = key
        if val == b:
            b_index = key

    temp_index = a_index + b_index # Складываем индексы, получаем новый ключ в словаре
    if ost != 0: # Если имеется остаток
        temp_index += ost # То прибавляем его к ключу
        ost = 0 # И обнуляем

    if temp_index > 15: # Если индекс (ключ) учешёл за пределы 15
        temp_index -= 16 # Смещаем его на начало
        ost = 1 # Запоминаем остаток

    new_number.appendleft(codedict[temp_index]) # По ключу в словаре ищем 16-ричный символ, помещаем в стек слева

    if not first: # Если первое число оказалось короче второго
        while second: # Заполняем стек значениями второго числа, не забывая про возможные остатки
            b = second.pop()
            for key, val in codedict.items():
                if val == b:
                    b_index = key
            if ost != 0:
                b_index += ost
            new_number.appendleft(codedict[b_index])
            b_index = 0
        flag = 1 # Устанавливаем флаг

    if not second: # То же самое, если второе число оказалось короче первого
        while first:
            a = first.pop()
            for key, val in codedict.items():
                if val == a:
                    a_index = key
            if ost != 0:
                a_index += ost
            new_number.appendleft(codedict[a_index])
            a_index = 0
        flag = 1

print(new_number)
